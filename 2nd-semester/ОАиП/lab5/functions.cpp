#include "header.h"																//хэдер с прототипами функций и необходимыми библиотеками

stack* allocate_memory()														//функция выделения памяти для элемента стека
{
	stack* st;

	st = (stack*)calloc(1, sizeof(stack));

	if (!st) return 0;
	return st;
}

void push(stack **st, int ps, char br)											//функция добавления элемента в стек
{
	stack* st1 = *st;															//сохранение верхнего элемента стека

	*st = allocate_memory();													//выделение памяти для нового элемента
	if (!st) return;

	(*st)->pos = ps;															//заполнение полей нового элемента
	(*st)->bracket = br;

	(*st)->next = st1;															//перемещение указателя на вершину стека на новый элемент
	st1 = *st;
}

int pop(stack** st)																//функция удаления последнего элемента из стека
{
	stack* st1;																	
	st1 = *st;																	//сохранение верхнего элемента стека
	int ps = (*st)->pos;														//сохранение позиции скобки

	*st = (*st)->next;															//перемещение указателя на вершину стека на следующий элемент
	free(st1);																	//очистка памяти удаляемого эл-та

	return ps;																	
}

void free_stack(stack* st)														//функция очистки стека
{
	while (st)																	//пока в стеке есть элементы, удалять их
		pop(&st);
}

int* check(char* str, stack* st, int* k)										//функция поиска ошибок
{
	int i = 0,
		j = 0;

	int* arr = allocate_memory_int(get_length(str));							//выделение памяти для массива ошибок
	
	while (i != get_length(str))												//пока не достигнут конец строки
	{
		if (*(str + i) == '(' || *(str + i) == '[' || *(str + i) == '{')
			push(&st, i, *(str + i));											//добавление открывающей скобки в стек

		if (*(str + i) == ')' || *(str + i) == ']' || *(str + i) == '}')		//если встречена закрывающая скобка
		{
			if (!st)															//если стек пуст
			{
				*(arr + *k) = i;												//добавление индекса скобки в массив ошибок
				(*k)++;															//увеличение счётчика ошибок
			}
			else
			{
				if (((*(str + i) == ')' && st->bracket == '(') || (*(str + i) == '}' && st->bracket == '{')	//если открывающей скобке соответствует закрывающая того же типа
					|| (*(str + i) == ']' && st->bracket == '[')))
				{
					pop(&st);													//удаление открывающей скобки из стека
				}
				else
				{
					*(arr + *k) = i;											//добавление индекса скобки в массив ошибок
					(*k)++;														//увеличение счётчика ошибок
					pop(&st);													//удаление открывающей скобки из стека
				}

			}
		}
		i++;
	}

	while (st)																	//если в стеке остались открывающие скобки
	{
		*(arr + *k) = pop(&st);													//очистка стека и добавление индекса скобки в массив ошибок
		(*k)++;																	//увеличение счётчика ошибок
	}

	arr = reallocate_memory_int(arr, *k);										//перевыделение памяти для массива ошибок
	sort(arr, *k);																//сортировка массива ошибок

	return arr;
}

void highlight(int* arr, char* str)												//функция подсветки ошибок							
{
	HANDLE h;
	h = GetStdHandle(STD_OUTPUT_HANDLE);

	int i = 0;

	for (int i = 0, k = 0; i < get_length(str); i++)
	{
		if (i == *(arr + k))													//если индекс очередного символа совпадает с индексом из массива ошибок
		{
			SetConsoleTextAttribute(h, (((4 << 4) | 0)));						//установка красного цвета фона
			putc(*(str + i), stdout);
			SetConsoleTextAttribute(h, (((0 << 4) | 15)));						//установка чёрного цвета фона
			k++;
		}
		else
			putc(*(str + i), stdout);
	}
}