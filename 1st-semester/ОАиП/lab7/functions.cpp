#include "header.h"																//хэдер с прототипами функций и необходимыми библиотеками

int input_nat()																	//функция ввода натурального числа
{
	int n = 0;																	//размерность массива
	int k = 1;																	//вспомогательная переменная для проверки на ввод целого числа

	do																			//ввод размерности массива с проверкой на целое число
	{
		rewind(stdin);															//очистка буфера
		k = scanf_s("%d", &n);

		if (!k || n <= 0)
			printf("Должно быть введено натуральное число!\n");
	} while (!k || n <= 0);														//если введено не целое число, цикл повторяется

	return n;
}

char** allocate_memory(int n)													//функция выделения памяти для массива символьных строк
{
	char** text;
	int i = 0;

	text = (char**)calloc(n, sizeof(char*));									//выделение памяти для n строк
	if (!text)																	//проверка, была ли выделена память
	{
		printf("Память не была выделена!");
		return 0;
	}

	for (i = 0; i < n; i++)
		*(text + i) = (char*)calloc(500, sizeof(char));							//выделение памяти для каждой строки

	return text;
}

int* allocate_memory_int(int n)													//функция выделения памяти для массива целых чисел
{
	int* a;
	
	a = (int*)calloc(n, sizeof(int));											//выделение памяти для n чисел
	if (!a)																		//проверка, была ли выделена память
	{
		printf("Память не была выделена!");
		return 0;
	}

	return a;
}

void get_string(char* str)														//функция ввода строки
{
	int i = 0;

	if (str)
	{
		rewind(stdin);															//очистка буфера
		while (i < 500)
		{
			*(str + i) = getchar();												//ввод очередного символа
			if (*(str + i) == '\n')												//если ввод строки окончен досрочно нажатием Enter, то цикл прерывается
				break;
			i++;
		}
		*(str + i) = '\0';														//размещение нуль-символа в конце строки
	}
}

void get_text(char** text, int n)												//функция прототипа ввода текста
{
	int i = 0;
	for (i = 0; i < n; i++)
		get_string(*(text + i));												//ввод очередной строки

	*(*(text + n - 1) + get_length(*(text + n - 1))) = EOF;						//размещение символа "конец файла" в конце текста
}

int number_of_words(char** text)												//функция нахождения кол-ва слов в тексте
{
	int count = 0,																//счётчик слов
		i = 0,
		j = 0;

	while (*(*(text + i) + j) != EOF)											//пока не достигнут конец текста
	{
		if (*(*(text + i) + j) == '\0')											//если встречен нуль-символ, то переходим к следующей строке
		{
			if (**(text + i) != ' ') count++;									//если строка не начинается с пробела, то учитываем первое слово
			i++; 
			j = 0;
			continue;
		}

		if (*(*(text + i) + j) == ' ' && *(*(text + i) + j + 1) != ' ') count++;	//если после пробела находится буква, то увеличиваем счётчик слов
		j++;
	}
	if (**(text + i) != ' ') count++;

	return count;
}

int get_length(char* str)														//функция определения длины строки
{
	int i = 0;																	//счётчик кол-ва символов в строке

	while (*(str + i) != '\0') i++;												//увеличивать счётчик, пока не будет встречен нуль-символ

	return i;
}

char* copy(char* str, int k)													//функция копирования одного слова из строки, начиная с n-го символа
{
	#define ch *(str + k + p)													//макрос для упрощения восприятия кода

	char* word;																	//символьная строка, содержащая слово
	int p = 0,																	//длина этой строки
		i = 0;

	while (ch != ' ' && ch != '!' && ch != '?' && ch != '.' && ch != ','
		&& ch != ':' && ch != ';' && ch != '\0' && ch != EOF) p++;				//пока не встречен знак препинания
	word = (char*)calloc(p, sizeof(char));										//выделение памяти для массива

	if (word)																	//если память была выделена
	{
		for (i = 0; i < p; i++)
			*(word + i) = *(str + k + i);										//копирование очередного символа
		*(word + i) = '\0';														//размещение нуль-символа в конце строки
	}

	return word;
}

int compare(char* str, char* str1)												//функция сравнения двух строк
{
	int i = 0;

	if (get_length(str) != get_length(str1)) return 0;							//если длины строк отличаются, то выполнение функции прекращается

	for (i = 0; i < get_length(str); i++)
		if (*(str + i) != *(str1 + i)) return 0;								//если хотя бы один символ не совпадает, то выполнение функции прекращается

	return 1;																	//функция возвращает 1 при успешном выполнении и 0 при неудачном
}


void find(char** text, char** words, int* array)								//функция нахождения повторяющихся слов
{
	#define c *(*(text + i) + j)												//макрос для упрощения восприятия кода

	char* temp;																	//строка-буфер

	int i = 0,	
		j = 0,
		k = 0,
		p = 0,
		flag = 0;																//переменная для проверки на совпадение строк

	temp = (char*)calloc(500, sizeof(char));

	while (*(*(text + i) + j) != EOF)											//пока не достигнут конец текста
	{
		while (c == ' ' || c == '!' || c == '?' || c == '.' || c == ',' || c == ':' || c == ';') j++;		//если очередной символ — знак препинания, то 
		if (*(*(text + i) + j) == '\0')																		//если встречен нуль-символ, то переходим к следующей строке
		{
			i++;
			j = 0;
			continue;
		}
		if (*(*(text + i) + j) >= 65 && *(*(text + i) + j) <= 90) *(*(text + i) + j) += 32;					//приведение символов букв к нижнему регистру
		
		temp = copy(*(text + i), j);											//копирование строки, содержащей слово, в буфер

		for (p = 0; p < k; p++)													//сравнение очередного слова с уже занесёнными в массив слов
		{
			flag = compare(*(words + p), temp);									
			if (flag)															//если такое слово уже занесено в массив
			{
				*(array + p) += 1;												//счётчик повторений слова увеличивается
				break;
			}
		}
		if (!flag)																//если такое слово ещё не занесено в массив
		{
			*(words + k) = temp;												//занесение слова в массив из буфера
			*(array + k) += 1;													//счётчик повторений слова увеличивается
			k++;
		}

		j += get_length(temp);													//переход к концу слова
	}

	for (i = 0; i < k - 1; i++)													//сортировка двух массивов методом "пузырька" по убыванию, в зависимости от кол-ва повторений слов в тексте
		for (j = 0; j < k - i - 1; j++)
			if (*(array + j) <= *(array + j + 1))
			{
				p = *(array + j);												//замена местами элементов в массиве, хранящем кол-ва повторений слов
				*(array + j) = *(array + j + 1);
				*(array + j + 1) = p;
				temp = *(words + j);											//замена местами элементов в массиве, хранящем слова
				*(words + j) = *(words + j + 1);
				*(words + j + 1) = temp;
			}
}

void result(char** words, int* array, int n)									//функция вывода результата
{
	int i = 0,
		p = 0;

	while (*(array + p) > 0) p++;
	if (p < n)																	//если кол-во уникальных слов меньше, чем введённое, то вывести все уникальные слова
	{
		for (i = 0; i < p; i++)
			printf("%10s — %d повторения\n", *(words + i), *(array + i));
		return;
	}

	for (i = 0; i < n; i++)														//вывод n запрашиваемых наиболее часто встречающихся слов
		printf("%10s — %d повторения\n", *(words + i), *(array + i));
}