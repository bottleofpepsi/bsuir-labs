#include "header.h"																//хэдер с прототипами функций и необходимыми библиотеками

int input_nat()																	//функция ввода натурального числа
{
	int n = 0;																	//размерность массива
	int k = 1;																	//вспомогательная переменная для проверки на ввод целого числа

	do																			//ввод размерности массива с проверкой на целое число
	{
		rewind(stdin);															//очистка буфера
		k = scanf_s("%d", &n);

		if (!k || n <= 0)
			printf("Должно быть введено натуральное число!\n");
	} while (!k || n <= 0);														//если введено не целое число, цикл повторяется

	return n;
}

char** allocate_memory(int n)													//функция выделения памяти для массива символьных строк
{
	char** text;
	int i = 0;

	text = (char**)calloc(n, sizeof(char*));									//выделение памяти для n строк
	if (!text)																	//проверка, была ли выделена память
	{
		printf("Память не была выделена!");
		return 0;
	}

	for (i = 0; i < n; i++)
		*(text + i) = (char*)calloc(500, sizeof(char));							//выделение памяти для каждой строки

	return text;
}

int* allocate_memory_int(int n)													//функция выделения памяти для массива целых чисел
{
	int* a;

	a = (int*)calloc(n, sizeof(int));											//выделение памяти для n чисел
	if (!a)																		//проверка, была ли выделена память
	{
		printf("Память не была выделена!");
		return 0;
	}

	return a;
}

void get_string(char* str)														//функция ввода строки
{
	int i = 0;

	if (str)
	{
		rewind(stdin);															//очистка буфера
		while (i < 500)
		{
			*(str + i) = getchar();												//ввод очередного символа
			if (*(str + i) == '\n')												//если ввод строки окончен досрочно нажатием Enter, то цикл прерывается
				break;
			i++;
		}
		*(str + i) = '\0';														//размещение нуль-символа в конце строки
	}
}

void get_text(char** text, int n)												//функция прототипа ввода текста
{
	int i = 0;
	for (i = 0; i < n; i++)
		get_string(*(text + i));												//ввод очередной строки

	*(*(text + n - 1) + get_length(*(text + n - 1))) = EOF;						//размещение символа "конец файла" в конце текста
}

int number_of_words(char** text)												//функция нахождения кол-ва слов в тексте
{
	int count = 0,																//счётчик слов
		i = 0,
		j = 0;

	while (*(*(text + i) + j) != EOF)											//пока не достигнут конец текста
	{
		if (*(*(text + i) + j) == '\0')											//если встречен нуль-символ, то переходим к следующей строке
		{
			if (**(text + i) != ' ') count++;									//если строка не начинается с пробела, то учитываем первое слово
			i++;
			j = 0;
			continue;
		}

		if (*(*(text + i) + j) == ' ' && *(*(text + i) + j + 1) != ' ') count++;	//если после пробела находится буква, то увеличиваем счётчик слов
		j++;
	}
	if (**(text + i) != ' ') count++;

	return count;
}

int get_length(char* str)														//функция определения длины строки
{
	int i = 0;																	//счётчик кол-ва символов в строке

	while (*(str + i) != '\0') i++;												//увеличивать счётчик, пока не будет встречен нуль-символ

	return i;
}

char* copy(char* str, int k)													//функция копирования одного слова из строки, начиная с n-го символа
{
	#define ch *(str + k + p)													//макрос для упрощения восприятия кода

	char* word;																	//символьная строка, содержащая слово
	int p = 0,																	//длина этой строки
		i = 0;

	while (ch != ' ' && ch != '!' && ch != '?' && ch != '.' && ch != ',' && ch != ':' && ch != ';' && ch != '\0' && ch != EOF) p++;	//пока не встречен знак препинания
	word = (char*)calloc(p, sizeof(char));										//выделение памяти для массива

	if (word)																	//если память была выделена
	{
		for (i = 0; i < p; i++)
			*(word + i) = *(str + k + i);										//копирование очередного символа
		*(word + i) = '\0';														//размещение нуль-символа в конце строки
	}

	return word;
}

int compare(int count, ...)														//функция сравнения нескольких строк
{
	va_list args;																//макрос для работы с переменным кол-вом параметров
	int i = 0,
		j = 0;
	char** str;
	
	va_start(args, count);														//считывание первого, явного аргумента
	str = (char**)calloc(count, sizeof(char*));
	if (!str) return 0;

	*str = va_arg(args, char*);													//считывание первого необязательного параметра (строки)
	for (j = 1; j < count; j++)
	{
		*(str + j) = va_arg(args, char*);										//считывание очередного необязательного параметра (строки)

		if (get_length(*(str + j - 1)) != get_length(*(str + j))) return 0;		//если длины строк отличаются, то выполнение функции прекращается

		for (i = 0; i < get_length(*(str + j)); i++)
			if (*(*(str + j - 1) + i) != *(*(str + j) + i)) return 0;			//если хотя бы один символ не совпадает, то выполнение функции прекращается
	}
	va_end(args);																//прекращение работы с переменным списком параметров

	return 1;																	//функция возвращает 1 при успешном выполнении и 0 при неудачном
}


void find(char** text, char** words, int* array)								//функция нахождения повторяющихся слов
{
	#define c *(*(text + i) + j)												//макрос для упрощения восприятия кода

	char* temp;																	//строка-буфер

	int i = 0,
		j = 0,
		k = 0,
		p = 0,
		flag = 0;																//переменная для проверки на совпадение строк

	temp = (char*)calloc(500, sizeof(char));

	while (*(*(text + i) + j) != EOF)											//пока не достигнут конец текста
	{
		while (c == ' ' || c == '!' || c == '?' || c == '.' || c == ',' || c == ':' || c == ';') j++;	//если очередной символ — знак препинания, то 
		if (*(*(text + i) + j) == '\0')											//если встречен нуль-символ, то переходим к следующей строке
		{
			i++;
			j = 0;
			continue;
		}
		if (*(*(text + i) + j) >= 65 && *(*(text + i) + j) <= 90) *(*(text + i) + j) += 32;	//приведение символов букв к нижнему регистру

		temp = copy(*(text + i), j);											//копирование строки, содержащей слово, в буфер

		for (p = 0; p < k; p++)													//сравнение очередного слова с уже занесёнными в массив слов
		{
			flag = compare(2, *(words + p), temp);
			if (flag)															//если такое слово уже занесено в массив
			{
				*(array + p) += 1;												//счётчик повторений слова увеличивается
				break;
			}
		}
		if (!flag)																//если такое слово ещё не занесено в массив
		{
			*(words + k) = temp;												//занесение слова в массив из буфера
			*(array + k) += 1;													//счётчик повторений слова увеличивается
			k++;
		}

		j += get_length(temp);													//переход к концу слова
		flag = 0;
	}

	hoor(words, array, 0, k - 1);												//сортировка методом Хоара по убыванию
}

void hoor(char** s, int* a, int l, int r)										//функция сортировки методом Хоара по убыванию
{
	int i = l,																	//левый край
		j = r,																	//правый край
		mid = (l + r) / 2;														//опорный элемент

	if (l >= r) return;															//если границы охватывают только один элемент, то прекратить выполнение
	while (!0)																	//бесконечный цикл
	{
		while (*(a + i) > *(a + mid)) i++;										//ищем слева очередной эл-т меньший, чем опорный элемент 	
		while (*(a + j) < *(a + mid)) j--;										//ищем справа очередной эл-т больший, чем опорный элемент 	

		if (i >= j)	break;
																				//меняем эти элементы местами
		swap_int(a, i, j);														//замена местами элементов массива чисел
		swap_str(s, i++, j--);													//замена местами элементов массива строк
	}

	hoor(s, a, l, j);															//рекурсивно применяем эту же функцию						
	hoor(s, a, j + 1, r);														
}

void swap_int(int* a, int k, int p)												//функции замены двух чисел местами в массиве
{
	int tmp;
	tmp = *(a + k);
	*(a + k) = *(a + p);
	*(a + p) = tmp;
}

void swap_str(char** a, int k, int p)											//функция замены двух чисел строк в массиве
{
	char* buffer;
	buffer = *(a + k);
	*(a + k) = *(a + p);
	*(a + p) = buffer;
}

void result(char** words, int* array, int n)									//функция вывода результата
{
	int i = 0,
		p = 0;

	while (*(array + p) > 0) p++;
	if (p < n)																	//если кол-во уникальных слов меньше, чем введённое, то вывести все уникальные слова
	{
		for (i = 0; i < p; i++)
			printf("%s — %d повторения\n", *(words + i), *(array + i));
		return;
	}

	for (i = 0; i < n; i++)														//вывод n запрашиваемых наиболее часто встречающихся слов
		printf("%s — %d повторения\n", *(words + i), *(array + i));
}